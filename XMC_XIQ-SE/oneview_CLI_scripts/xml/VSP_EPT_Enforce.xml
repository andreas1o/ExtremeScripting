<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script name="VSP EPT Enforce">
    <abortOnError>true</abortOnError>
    <auditLogEnabled></auditLogEnabled>
    <category>,Config,</category>
    <comments>Enforce XMC NAC and Endpoint-Tracking config to VSP switch - v1.5</comments>
    <content>'''
This script is provided free of charge by Extreme. We hope such scripts are
helpful when used in conjunction with Extreme products and technology and can
be used as examples to modify and adapt for your ultimate requirements.
Extreme will not provide any official support for these scripts. If you do
have any questions or queries about any of these scripts you may post on
Extreme's community website "The Hub" (https://community.extremenetworks.com/)
under the scripting category.

ANY SCRIPTS PROVIDED BY EXTREME ARE HEREBY PROVIDED "AS IS", WITHOUT WARRANTY
OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL EXTREME OR ITS THIRD PARTY LICENSORS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE USE OR DISTRIBUTION OF SUCH
SCRIPTS.
'''

##########################################################
# XMC Script: VSP-EPT-Enforce                            #
# Written by Ludovico Stevens, CSE Extreme Networks      #
##########################################################
# Push Endpoint-Tracking (EPT) configuration to VSP switch

__version__ = '1.5'

# 1.0 - Initial
# 1.1 - VOSS 8.2 introduces the Segmented Mgmt Stack; configuration of RADIUS server must no longer specify a source-ip
# 1.2 - Modifications so that it can be used on VSP ports initially set as auto-sense ports
# 1.3 - Added MLT-id list input field so that MLTs can be more easily selected
# 1.4 - Added Universal Hardware support and updated to latest function versions
# 1.5 - Now detects and disables auto-sense on ports where EPT enabled
#     - Can now simply update RADIUS server secret key, without having to delete and re-create the server

# Todo:


#
# XMC Metadata
#
'''
#@MetaDataStart
#@DetailDescriptionStart
#######################################################################################
#######################################################################################
# 
# This script allows the XMC operator to easily configure a VSP switch for Endpoint-
# Tracking (EPT) based on the ExtremeControl NAC configuration.
#
# WARNING: if you use this script to re-enforce the EPT config to an already operational
# switch and you specify any of the EPT global settings (Auto I-SID offset or Visibility
# mode pull-downs), this script will temporarily disable and re-enable EPT which will
# result in any existing EPT bindings getting flushed and that could cause a brief
# connectivity loss for server VMs, the time for their MACs to be RADIUS re-validated
# and for the VLAN:ISID binding to be re-applied on the access ports.
#
#  1 - Add the switch under XMC Access Control Engine Group
#  2 - And, still under XMC Access Control, configure the switch for:
#      - Primary/Secondary engine.
#      - Authentication Access type (Manual RADIUS Configuration).
#      - RADIUS Attributes to Send (Fabric Attach attributes).
#      - RADIUS accounting (disabled; not supported with VOSS EPT).
#      - Advanced settings / Override RADIUS shared secret key.
#        Note that this script can currently only work if the shared secret is set under
#        switch advanced settings, override RADIUS; if the shared secret is set under the
#        engine settings, currently it is not possible for this script to access that
#        info via NBI.
#      - Advanced settings / Reauthentication behaviour.
#        (for VSP EPT select "RFC 3576 - Generic CoA Colon Delimited")
#  3 - Perform an Access Control Engine Enforce on XMC
#  4 - Run this script against the VSP switch (or multiple VSP switches simultaneously).
#  5 - Select the access ports which will be configured for EPT; select none if enforcing only
#      global changes.
#      (If you wish to apply the config to all access ports, simply select ALL ports;
#      this script is intelligent enough to infer VSP existing NNI and FA ports and will
#      remove them from the port selection; if ports are members of MLT or SMLT UNIs, EPT will
#      automatically get enabled on the corresponding MLT interface)
#  6 - Select the desired EPT port configuration:
#      - Enable: EPT is created and enabled on ports (if any ports were selected) and EPT
#                global settings are enforced.
#      - Disable: EPT is created but disabled on ports.
#              (if this option is selected then simply skip to step 9 directly)
#      - None: EPT is deleted from ports.
#              (if this option is selected then simply skip to step 9 directly)
#  7 - Optionally provide a list of MLT-ids as an alternative or as complement to selecting the
#      LAG ports in step 5 (e.g. if it was not easy to spot the right LAG ports there)
#  8 - Select the desired Auto-ISID-Offset mode:
#      - Empty: Whatever setting is on the VSP switch it will not be changed.
#      - Disable: I-SID must be returned with VLAN-id in RADIUS attribute.
#      - Offset selection: If no I-SID is returned in RADIUS response then this I-SID offset
#                          will be added to the VLAN-id returned by RADIUS to obtain the I-SID.
#  9 - Select the desired Visibility mode:
#      - Empty: Whatever setting is on the VSP switch it will not be changed.
#      - Disable: VSP will only RADIUS authenticate MACs which do not belong to static bindings.
#      - Enable: VSP will RADIUS authenticate all MACs, including MACs on static bindings.
# 10 - Sanity/Debug options are allowed at the end of user inputs. Sanity will result is the script
#      running but config commands will not be executed on the switch; useful to see what the script
#      does without it actually changing any switch settings. Debug can be enabled when/if reporting
#      problems
# 11 - Finally, RUN the script
#
# The script will automatically configure all of the following:
# - Primary and Secondary RADIUS Servers, including shared secret
# - RADIUS dynamic-client (RFC3576 Change-of-Authorization)
# - NTP or SNTP configuration to match that of the XMC Server, including the right timezone
#   (RFC3576 Change-of-Authorization requires the switch and server to have the same time)
#   Note: if XMC has no NTP server configured, then no NTP/SNTP config will be applied to the
#   VSP. If the script is unable to extract NTP server and time-zone from XMC then it is possible to
#   hard code the desired values in the NtpList and TimeZone global variables of this script.
# - EPT global and port level configuration
# - If the port selection included NNI or FA ports these will be filtered out.
# - If some or all the ports selected are members of MLT or SMLT interfaces, then the EPT config
#   will be applied to the corresponding MLT interface (again NNI MLTs and FA MLTs will be ignored)
#
# This script can be run multiple times against the same VSP, either to change the
# configuration or enable EPT on different access ports or indeed to subsequently
# disable or delete EPT on certain ports.
# If running the script a second time to change the port EPT config, simply
# set the desired EPT port config mode and execute the script (no need to populate the
# other dialogues if those config options have already been set).
# In particular, if running the script to disable/delete EPT on some ports then only the first
# EPT port config dialogue needs to be set (to None or Disable) and then the script can be executed;
# in this case the script will execute even if the VSP switch has already been deleted
# from the XMC Access Control configuration.
# This script uses the XMC North Bound interface API to extract the Access Control switch
# configuration; therefore the XMC user running this script must have authorization rights
# under "Northbound API / Access Control Northbound Interface Read Access"
#
# Limitations: This script will only work on XMC Linux based VM installations.
#              Running this script on a Windows based XMC installation will fail.
#######################################################################################
#@DetailDescriptionEnd
# ( = &amp;#40;
# ) = &amp;#41;
# , = &amp;#44;
# &lt; = &amp;lt;
# &gt; = &amp;gt;

#@SectionStart (description = "Endpoint-Tracking port level configuration")
#    @VariableFieldLabel (
#        description = "EPT port config mode. If selecting None or Disable can skip all other inputs below",
#        type = string,
#        required = yes,
#        readOnly = no,
#        validValues = [Enable: EPT created and enabled on ports, Disable: EPT created but disabled on ports, None: EPT deleted on ports],
#        name = "userInput_eptPortMode",
#        value = "Enable: EPT created and enabled on ports",
#    )
#    @VariableFieldLabel (
#        description = "Optional MLT id list as an alternative or to complement any ports already selected in the port chooser dialogue",
#        type = string,
#        required = no,
#        readOnly = no,
#        name = "userInput_mltIdList",
#    )
#@SectionEnd

#@SectionStart (description = "Endpoint-Tracking global configuration")
#    @VariableFieldLabel (
#        description = "Auto-ISID-Offset. If XMC Control returns only VLAN-id&amp;#44 offset is added to obtain L2 I-SID",
#        type = string,
#        required = no,
#        readOnly = no,
#        validValues = [Disable, CTC-Reading: I-SIDs 2800000, Range0: I-SIDs 2000000, Range1: I-SIDs 2010000, Range2: I-SIDs 2020000, Range3: I-SIDs 2030000, Range4: I-SIDs 2040000],
#        name = "userInput_autoIsidOffset",
#    )
#    @VariableFieldLabel (
#        description = "Visibility Mode. If enabled&amp;#44 VSP will also notify XMC Control of MACs learnt on static bindings",
#        type = string,
#        required = no,
#        readOnly = no,
#        validValues = [Enable, Disable],
#        name = "userInput_visibilityMode",
#    )
#@SectionEnd

#@SectionStart (description = "Other useful access features to enable on Endpoint-Tracking ports")
#    @VariableFieldLabel (
#        description = "Spoof-Detect. Automatically discard all traffic from MAC if MAC is spoofing the default-gatewaty IP",
#        type = string,
#        required = no,
#        readOnly = no,
#        validValues = [Enable, Disable],
#        name = "userInput_spoofDetect",
#    )
#    @VariableFieldLabel (
#        description = "SLPP-Guard. Automatically shut down access ports if a loop is detected on those ports",
#        type = string,
#        required = no,
#        readOnly = no,
#        validValues = [Enable, Disable],
#        name = "userInput_slppGuard",
#    )
#@SectionEnd

#@SectionStart (description = "Sanity / Debug")
#    @VariableFieldLabel (
#        description = "Sanity: enable if you do not trust this script and wish to first see what it does. In sanity mode config commands are not executed",
#        type = string,
#        required = no,
#        validValues = [Enable, Disable],
#        name = "userInput_sanity",
#    )
#    @VariableFieldLabel (
#        description = "Debug: enable if you need to report a problem to the script author",
#        type = string,
#        required = no,
#        validValues = [Enable, Disable],
#        name = "userInput_debug",
#    )
#@SectionEnd
#@MetaDataEnd
'''



##########################################################
# Ludo Standard library; Version 4.05d                    #
# Written by Ludovico Stevens, TME Extreme Networks      #
##########################################################
Debug = False    # Enables debug messages
Sanity = False   # If enabled, config commands are not sent to host (show commands are operational)

#
# Base functions
# v7
import re                           # Used by scriptName
import time                         # Used by exitError
ExitErrorSleep = 10

def debug(debugOutput): # v1 - Use function to include debugging in script; set above Debug variable to True or False to turn on or off debugging
    if Debug:
        print debugOutput

def exitError(errorOutput, sleep=ExitErrorSleep): # v3 - Exit script with error message and setting status appropriately
    if 'workflowMessage' in emc_vars: # Workflow
        time.sleep(sleep) # When workflow run on multiple devices, want ones that error to be last to complete, so THEY set the workflow message
        emc_results.put("deviceMessage", errorOutput)
        emc_results.put("activityMessage", errorOutput)
        emc_results.put("workflowMessage", errorOutput)
    emc_results.setStatus(emc_results.Status.ERROR)
    raise RuntimeError(errorOutput)

def abortError(cmd, errorOutput): # v1 - A CLI command failed, before bombing out send any rollback commands which may have been set
    print "Aborting script due to error on previous command"
    try:
        rollbackStack()
    finally:
        print "Aborting because this command failed: {}".format(cmd)
        exitError(errorOutput)

def scriptName(): # v1 - Returns the assigned name of the Script or Workflow
    name = None
    if 'workflowName' in emc_vars: # Workflow
        name = emc_vars['workflowName']
    elif 'javax.script.filename' in emc_vars: # Script
        nameMatch = re.search(r'\/([^\/\.]+)\.py$', emc_vars['javax.script.filename'])
        name = nameMatch.group(1) if nameMatch else None
    return name

def workflow_DeviceMessage(msg): # v1 - Set workflow messages appropriately; '&lt;&gt;' is replaced with device IP or list
    singleDeviceMsg = manyDevicesMsg = msg
    if '&lt;&gt;' in msg:
        devicesListStr = emc_vars['devices'][1:-1]
        singleDeviceMsg = msg.replace('&lt;&gt;', emc_vars['deviceIP']).replace('(s)', '').replace('(es)', '')
        if len(devicesListStr.split(',')) &gt; 1:
            manyDevicesMsg = msg.replace('&lt;&gt;', devicesListStr).replace('(s)', 's').replace('(es)', 'es')
        else:
            manyDevicesMsg = singleDeviceMsg
    emc_results.put("deviceMessage", singleDeviceMsg)
    emc_results.put("activityMessage", manyDevicesMsg)
    emc_results.put("workflowMessage", manyDevicesMsg)


#
# Family functions
# v3
Family = None # This needs to get set by setFamily()
FamilyChildren = { # Children will be rolled into parent family for these scripts
    'Extreme Access Series' : 'VSP Series',
    'Unified Switching VOSS': 'VSP Series',
    'Unified Switching EXOS': 'Summit Series',
    'Universal Platform VOSS': 'VSP Series',
    'Universal Platform EXOS': 'Summit Series',
    'Universal Platform Fabric Engine': 'VSP Series',
    'Universal Platform Switch Engine': 'Summit Series',
    'ISW-24W-4X': 'ISW-Series-Marvell',
}

def setFamily(cliDict={}, family=None): # v3 - Set global Family variable; automatically handles family children, as far as this script is concerned
    global Family
    if family:
        Family = family
    elif emc_vars["family"] in FamilyChildren:
        Family = FamilyChildren[emc_vars["family"]]
    elif emc_vars["deviceType"] in FamilyChildren:
        Family = FamilyChildren[emc_vars["deviceType"]]
    else:
        Family = emc_vars["family"]
    print "Using family type '{}' for this script".format(Family)
    if cliDict and Family not in cliDict:
        exitError('This scripts only supports family types: {}'.format(", ".join(list(cliDict.keys()))))
    return Family


#
# CLI functions
# v25
import re
RegexPrompt = re.compile('.*[\?\$%#&gt;]\s?$')
RegexError  = re.compile(
    '^%|\x07|error|invalid|cannot|unable|bad|not found|not exist|not allowed|no such|out of range|incomplete|failed|denied|can\'t|ambiguous|do not|unrecognized',
    re.IGNORECASE | re.MULTILINE
)
RegexNoError  = re.compile( # Messages which would be false positives for an error condition, when they are just a warning..
    '(?:'
    + 'Both ends of MACsec link cannot have the same key-parity value'
    + '|% Saving \d+ bytes to flash:startup-config' # ISW: copy running-config startup-config
    + ')',
    re.IGNORECASE | re.MULTILINE
)
RegexContextPatterns = { # Ported from acli.pl
    'ERS Series' : [
        re.compile('^(?:interface |router \w+$|route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$|ip igmp profile \d+$|wireless|application|ipv6 dhcp guard policy |ipv6 nd raguard policy )'), # level0
        re.compile('^(?:security|crypto|ap-profile |captive-portal |network-profile |radio-profile )'), # level1
        re.compile('^(?:locale)'), # level2
    ],
    'VSP Series' : [
        re.compile('^ *(?:interface |router \w+$|router vrf|route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$|application|i-sid \d+|wireless|logical-intf isis \d+|mgmt (?:\d|clip|vlan|oob)|ovsdb$)'), # level0
        re.compile('^ *(?:route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$)'), # level1
    ],
    'ISW-Series' : [
        re.compile('^ *(?:ringv2-group |interface )'), # level0
    ],
    'ISW-Series-Marvell' : [
        re.compile('^ *(?:ringv2-group |interface )'), # level0
    ],
}
RegexExitInstance = re.compile('^ *(?:exit|back|end|config|save)(?:\s|$)')
Indent = 3 # Number of space characters for each indentation
LastError = None
ConfigHistory = []

def cliError(outputStr): # v1 - Check command output for CLI error message
    if not RegexNoError.search(outputStr) and RegexError.search(outputStr):
        return True
    else:
        return False

def cleanOutput(outputStr): # v5 - Remove echoed command and final prompt from output
    if re.match(r'Error:', outputStr): # Case where emc_cli.send timesout: "Error: session exceeded timeout: 30 secs"
        return outputStr
    outputLines = outputStr.splitlines()
    lastLine = outputLines[-1]
    if RegexPrompt.match(lastLine):
        return '\n'.join(outputLines[1:-1])
    else:
        return '\n'.join(outputLines[1:])

def configChain(chainStr): # v2 - Produces a list of a set of concatenated commands (either with ';' or newlines)
    chainStr = re.sub(r'\n(\w)(\x0d?\n|\s*;|$)', chr(0) + r'\1\2', chainStr) # Mask trailing "\ny" or "\nn" on commands before making list
    # Checking for \x0d? is necessary when DOS text files are transferred to XIQ-SE, and read and processed locally..
    cmdList = map(str.strip, re.split(r'[;\n]', chainStr))
    cmdList = filter(None, cmdList) # Filter out empty lines, if any
    cmdList = [re.sub(r'\x00(\w)(\x0d?\n|$)', r'\n\1\2', x) for x in cmdList] # Unmask after list made
    return cmdList

def parseRegexInput(cmdRegexStr): # v1 - Parses input command regex for both sendCLI_showRegex() and xmcLinuxCommand()
    # cmdRegexStr format: &lt;type&gt;://&lt;cli-show-command&gt; [&amp; &lt;additional-show-cmd&gt;]||&lt;regex-to-capture-with&gt;
    if re.match(r'\w+(?:-\w+)?://', cmdRegexStr):
        mode, cmdRegexStr = map(str.strip, cmdRegexStr.split('://', 1))
    else:
        mode = None
    cmd, regex = map(str.strip, cmdRegexStr.split('||', 1))
    cmdList = map(str.strip, cmd.split('&amp;'))
    return mode, cmdList, regex

def formatOutputData(data, mode): # v3 - Formats output data for both sendCLI_showRegex() and xmcLinuxCommand()
    if not mode                 : value = data                                   # Legacy behaviour same as list
    elif mode == 'bool'         : value = bool(data)                             # No regex capturing brackets required
    elif mode == 'str'          : value = str(data[0]) if data else None         # Regex should have 1 capturing bracket at most
    elif mode == 'str-lower'    : value = str(data[0]).lower() if data else None # Same as str but string made all lowercase
    elif mode == 'str-upper'    : value = str(data[0]).upper() if data else None # Same as str but string made all uppercase
    elif mode == 'str-join'     : value = ''.join(data)                          # Regex with max 1 capturing bracket, joins list to string
    elif mode == 'str-nwlnjoin' : value = "\n".join(data)                        # Regex with max 1 capturing bracket, joins list to multi-line string
    elif mode == 'int'          : value = int(data[0]) if data else None         # Regex must have 1 capturing bracket at most
    elif mode == 'list'         : value = data                                   # If &gt; 1 capturing brackets, will be list of tuples
    elif mode == 'list-reverse' : value = list(reversed(data))                   # Same as list but in reverse order
    elif mode == 'list-diagonal': value = [data[x][x] for x in range(len(data))] # Regex pat1|pat2 = list of tuples; want [0][0],[1][1],etc
    elif mode == 'tuple'        : value = data[0] if data else ()                # Regex &gt; 1 capturing brackets on same line, returns 1st tuple
    elif mode == 'dict'         : value = dict(data)                             # Regex must have 2 capturing brackets exactly
    elif mode == 'dict-reverse' : value = dict(map(reversed, data))              # Same as dict, but key/values will be flipped
    elif mode == 'dict-both'    : value = dict(data), dict(map(reversed, data))  # Returns 2 dict: dict + dict-reverse
    elif mode == 'dict-diagonal': value = dict((data[x][x*2],data[x][x*2+1]) for x in range(len(data))) # {[0][0]:[0][1], [1][2]:[1][3], etc}
    elif mode == 'dict-sequence': value = dict((data[x*2][0],data[x*2+1][1]) for x in range(len(data)/2)) # {[0][0]:[1][1], [2][0]:[3][1], etc}
    else:
        RuntimeError("formatOutputData: invalid scheme type '{}'".format(mode))
    return value

def sendCLI_showCommand(cmd, returnCliError=False, msgOnError=None): # v2 - Send a CLI show command; return output
    global LastError
    resultObj = emc_cli.send(cmd)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and cliError("\n".join(outputStr.split("\n")[:4])): # If there is output, check for error in 1st 4 lines only (timestamp banner might shift it by 3 lines)
            if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
                LastError = outputStr
                if msgOnError:
                    print "==&gt; Ignoring above error: {}\n\n".format(msgOnError)
                return None
            abortError(cmd, outputStr)
        LastError = None
        return outputStr
    else:
        exitError(resultObj.getError())

def sendCLI_showRegex(cmdRegexStr, debugKey=None, returnCliError=False, msgOnError=None): # v1 - Send show command and extract values from output using regex
    # Regex is by default case-sensitive; for case-insensitive include (?i) at beginning of regex on input string
    mode, cmdList, regex = parseRegexInput(cmdRegexStr)
    for cmd in cmdList:
        # If cmdList we try each command in turn until one works; we don't want to bomb out on cmds before the last one in the list
        ignoreCliError = True if len(cmdList) &gt; 1 and cmd != cmdList[-1] else returnCliError
        outputStr = sendCLI_showCommand(cmd, ignoreCliError, msgOnError)
        if outputStr:
            break
    if not outputStr: # returnCliError true
        return None
    data = re.findall(regex, outputStr, re.MULTILINE)
    debug("sendCLI_showRegex() raw data = {}".format(data))
    # Format we return data in depends on what '&lt;type&gt;://' was pre-pended to the cmd &amp; regex
    value = formatOutputData(data, mode)
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, value))
        else: debug("sendCLI_showRegex OUT = {}".format(value))
    return value

def sendCLI_configCommand(cmd, returnCliError=False, msgOnError=None, waitForPrompt=True): # v4 - Send a CLI config command
    global LastError
    cmd = re.sub(r':\/\/', ':' + chr(0) + chr(0), cmd) # Mask any https:// type string
    cmd = re.sub(r' *\/\/ *', r'\n', cmd) # Convert "//" to "\n" for embedded // passwords
    cmd = re.sub(r':\x00\x00', r'://', cmd) # Unmask after // replacemt
    cmdStore = re.sub(r'\n.+$', '', cmd, flags=re.DOTALL) # Strip added "\n"+[yn] or // passwords
    if Sanity:
        print "SANITY&gt; {}".format(cmd)
        ConfigHistory.append(cmdStore)
        LastError = None
        return True
    resultObj = emc_cli.send(cmd, waitForPrompt)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and cliError("\n".join(outputStr.split("\n")[:4])): # If there is output, check for error in 1st 4 lines only
            if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
                LastError = outputStr
                if msgOnError:
                    print "==&gt; Ignoring above error: {}\n\n".format(msgOnError)
                return False
            abortError(cmd, outputStr)
        ConfigHistory.append(cmdStore)
        LastError = None
        return True
    else:
        exitError(resultObj.getError())

def sendCLI_configChain(chainStr, returnCliError=False, msgOnError=None, waitForPrompt=True, abortOnError=True): # v4 - Send a list of config commands
    # Syntax: chainStr can be a multi-line string where individual commands are on new lines or separated by the semi-colon ";" character
    # Some embedded directive commands are allowed, these must always begin with the hash "#" character:
    # #error fail       : If a subsequent command generates an error, make the entire script fail
    # #error stop       : If a subsequent command generates an error, do not fail the script but stop processing firther commands
    # #error continue   : If a subsequent command generates an error, ignore it and continue executing remaining commands
    cmdList = configChain(chainStr)
    successStatus = True
    for cmd in cmdList[:-1]: # All but last
        embedded = re.match(r'^#error +(fail|stop|continue) *$', cmd)
        if embedded:
            errorMode = embedded.group(1)
            returnCliError = False if errorMode == 'fail' else True
            abortOnError = True if errorMode == 'stop' else False
            continue # After setting the above, we skip the embedded command
        success = sendCLI_configCommand(cmd, returnCliError, msgOnError)
        if not success:
            successStatus = False
            if abortOnError:
                return False
    # Last now
    success = sendCLI_configCommand(cmdList[-1], returnCliError, msgOnError, waitForPrompt)
    if not success:
        return False
    return successStatus

def printConfigSummary(): # v4 - Print summary of all config commands executed with context indentation
    global ConfigHistory
    emc_cli.close()
    if not len(ConfigHistory):
        print "No configuration was performed"
        return
    print "The following configuration was successfully performed on switch:"
    indent = ''
    level = 0
    if Family in RegexContextPatterns:
        maxLevel = len(RegexContextPatterns[Family])
    for cmd in ConfigHistory:
        if Family in RegexContextPatterns:
            if level &lt; maxLevel and RegexContextPatterns[Family][level].match(cmd):
                print "-&gt; {}{}".format(indent, cmd)
                level += 1
                indent = ' ' * Indent * level
                continue
            elif RegexExitInstance.match(cmd):
                if level &gt; 0:
                    level -= 1
                indent = ' ' * Indent * level
        print "-&gt; {}{}".format(indent, cmd)
    ConfigHistory = []


#
# XMC GraphQl &amp; RESTCONF required functions
# v3
from java.util import LinkedHashMap

def recursionKeySearch(nestedDict, returnKey): # v1 - Used by both nbiQuery() and nbiMutation() and restconfCall()
    for key, value in nestedDict.iteritems():
        if key == returnKey:
            return True, value
    for key, value in nestedDict.iteritems():
        if isinstance(value, (dict, LinkedHashMap)): # XMC Python is Jython where a dict is in fact a java.util.LinkedHashMap
            foundKey, foundValue = recursionKeySearch(value, returnKey)
            if foundKey:
                return True, foundValue
        return [None, None] # If we find nothing

def recursionStatusSearch(nestedDict): # v2 - Used by nbiMutation()
    for key, value in nestedDict.iteritems():
        if key == 'status':
            if 'message' in nestedDict and nestedDict['message']:
                return True, value, nestedDict['message']
            elif 'result' in nestedDict and 'msg' in nestedDict['result']: # For Policy mutations..
                return True, value, nestedDict['result']['msg']
            else:
                return True, value, None
    for key, value in nestedDict.iteritems():
        if isinstance(value, (dict, LinkedHashMap)): # XMC Python is Jython where a dict is in fact a java.util.LinkedHashMap
            foundKey, foundValue, foundMsg = recursionStatusSearch(value)
            if foundKey:
                return True, foundValue, foundMsg
        return [None, None, None] # If we find nothing

def replaceKwargs(queryString, kwargs): # v1 - Used by both nbiQuery() and nbiMutation() and restconfCall()
    for key in kwargs:
        replaceValue = str(kwargs[key]).lower() if type(kwargs[key]) == bool else str(kwargs[key])
        queryString = queryString.replace('&lt;'+key+'&gt;', replaceValue)
    return queryString


#
# XMC GraphQl NBI functions
# v14
LastNbiError = None
NbiUrl = None

def nbiQuery(jsonQueryDict, debugKey=None, returnKeyError=False, **kwargs): # v7 - Makes a GraphQl query of XMC NBI; if returnKey provided returns that key value, else return whole response
    global LastNbiError
    jsonQuery = replaceKwargs(jsonQueryDict['json'], kwargs)
    returnKey = jsonQueryDict['key'] if 'key' in jsonQueryDict else None
    debug("NBI Query:\n{}\n".format(jsonQuery))
    response = nbiSessionPost(jsonQuery, returnKeyError) if NbiUrl else emc_nbi.query(jsonQuery)
    debug("nbiQuery response = {}".format(response))
    if response == None: # Should only happen from nbiSessionPost if returnKeyError=True
        return None
    if 'errors' in response: # Query response contains errors
        if returnKeyError: # If we asked to return upon NBI error, then the error message will be held in LastNbiError
            LastNbiError = response['errors'][0].message
            return None
        abortError("nbiQuery for\n{}".format(jsonQuery), response['errors'][0].message)
    LastNbiError = None

    if returnKey: # If a specific key requested, we find it
        foundKey, returnValue = recursionKeySearch(response, returnKey)
        if foundKey:
            if Debug:
                if debugKey: debug("{} = {}".format(debugKey, returnValue))
                else: debug("nbiQuery {} = {}".format(returnKey, returnValue))
            return returnValue
        if returnKeyError:
            return None
        # If requested key not found, raise error
        abortError("nbiQuery for\n{}".format(jsonQuery), 'Key "{}" was not found in query response'.format(returnKey))

    # Else, return the full response
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, response))
        else: debug("nbiQuery response = {}".format(response))
    return response

def nbiMutation(jsonQueryDict, returnKeyError=False, debugKey=None, **kwargs): # v7 - Makes a GraphQl mutation query of XMC NBI; returns true on success
    global LastNbiError
    jsonQuery = replaceKwargs(jsonQueryDict['json'], kwargs)
    returnKey = jsonQueryDict['key'] if 'key' in jsonQueryDict else None
    if Sanity:
        print "SANITY - NBI Mutation:\n{}\n".format(jsonQuery)
        LastNbiError = None
        return True
    print "NBI Mutation Query:\n{}\n".format(jsonQuery)
    response = nbiSessionPost(jsonQuery, returnKeyError) if NbiUrl else emc_nbi.query(jsonQuery)
    debug("nbiQuery response = {}".format(response))
    if 'errors' in response: # Query response contains errors
        if returnKeyError: # If we asked to return upon NBI error, then the error message will be held in LastNbiError
            LastNbiError = response['errors'][0].message
            return None
        abortError("nbiQuery for\n{}".format(jsonQuery), response['errors'][0].message)

    foundKey, returnStatus, returnMessage = recursionStatusSearch(response)
    if foundKey:
        debug("nbiMutation status = {} / message = {}".format(returnStatus, returnMessage))
    elif not returnKeyError:
        # If status key not found, raise error
        abortError("nbiMutation for\n{}".format(jsonQuery), 'Key "status" was not found in query response')

    if returnStatus == "SUCCESS":
        LastNbiError = None
        if returnKey: # If a specific key requested, we find it
            foundKey, returnValue = recursionKeySearch(response, returnKey)
            if foundKey:
                if Debug:
                    if debugKey: debug("{} = {}".format(debugKey, returnValue))
                    else: debug("nbiQuery {} = {}".format(returnKey, returnValue))
                return returnValue
            if returnKeyError:
                return None
            # If requested key not found, raise error
            abortError("nbiMutation for\n{}".format(jsonQuery), 'Key "{}" was not found in mutation response'.format(returnKey))
        return True
    else:
        LastNbiError = returnMessage
        return False


#
# Port processing functions
# v6
RegexPort = re.compile('^(?:[1-9]\d{0,2}[/:])?\d+(?:[/:]\d)?$')
RegexPortRange = re.compile('^(?:([1-9]\d{0,2})([/:]))?(\d+)(?:[/:](\d))?-(?:([1-9]\d{0,2})[/:])?(\d+)(?:[/:](\d))?$')
RegexStarRange = re.compile('^([1-9]\d{0,2})(:)\*$') # XOS only
SlotPortRange = None # Gets set to dict by getSlotPortRanges()

def portValue(port): # v1 - Function to pass to sorted(key) to sort port lists
    slotPort = re.split('[/:]', port)
    if len(slotPort) == 3: # slot/port/chan format
        idx = int(slotPort[0])*400 + int(slotPort[1])*4 + int(slotPort[2])
    elif len(slotPort) == 2: # slot/port format
        idx = int(slotPort[0])*400 + int(slotPort[1])*4
    else: # standalone port (no slot)
        idx = int(slotPort[0])*4
    return idx

def getSlotPortRanges(): # v1 - Populates the SlotPortRange dict
    global SlotPortRange
    slotCommand = {'Summit Series': 'dict://show slot||^Slot-(\d+) +\S+ +\S+ +\S+ +(\d+)'} # Only XOS supported
    if Family not in slotCommand:
        SlotPortRange = {}
        return
    SlotPortRange = sendCLI_showRegex(slotCommand[Family])
    debug("getSlotPortRanges = {}".format(SlotPortRange))

def generatePortList(portStr, debugKey=None): # v3 - Given a port list/range, validates it and returns an ordered port list with no duplicates (can also be used for VLAN-id ranges)
    # This version of this function will not handle port ranges which span slots
    debug("generatePortList IN = {}".format(portStr))
    portDict = {} # Use a dict, will ensure no port duplicate keys
    for port in portStr.split(','):
        port = re.sub(r'^[\s\(]+', '', port) # Remove leading spaces  [ or '(' ]
        port = re.sub(r'[\s\)]+$', '', port) # Remove trailing spaces [ or ')' =&gt; XMC bug on ERS standalone units]
        if not len(port): # Skip empty string
            continue
        rangeMatch = RegexPortRange.match(port)
        starMatch = RegexStarRange.match(port)
        if rangeMatch: # We have a range of ports
            startSlot = rangeMatch.group(1)
            separator = rangeMatch.group(2)
            startPort = int(rangeMatch.group(3))
            startChan = int(rangeMatch.group(4)) if rangeMatch.group(4) else None
            endSlot = rangeMatch.group(5)
            endPort = int(rangeMatch.group(6))
            endChan = int(rangeMatch.group(7)) if rangeMatch.group(4) else None
            if endSlot and startSlot != endSlot:
                print "ERROR! generatePortList no support for ranges spanning slots: {}".format(port)
            elif (startChan or endChan) and endPort and startPort != endPort:
                print "ERROR! generatePortList no support for ranges spanning channelized ports: {}".format(port)
            elif not (startChan or endChan) and startPort &gt;= endPort:
                print "ERROR! generatePortList invalid range: {}".format(port)
            elif (startChan or endChan) and startChan &gt;= endChan:
                print "ERROR! generatePortList invalid range: {}".format(port)
            else: # We are good
                if startChan:
                    for portCount in range(startChan, endChan + 1):
                        portDict[startSlot + separator + str(startPort) + separator + str(portCount)] = 1
                else:
                    for portCount in range(startPort, endPort + 1):
                        if startSlot: # slot-based range
                            portDict[startSlot + separator + str(portCount)] = 1
                        else: # simple port range (no slot info)
                            portDict[str(portCount)] = 1
        elif starMatch: # We have a slot/* range
            slot = starMatch.group(1)
            separator = starMatch.group(2)
            if SlotPortRange == None: # Structure not populated
                getSlotPortRanges()
            if SlotPortRange:
                if slot in SlotPortRange:
                    for portCount in range(1, int(SlotPortRange[slot]) + 1):
                        portDict[slot + separator + str(portCount)] = 1
                else:
                    print "Warning: no range for slot {}; skipping: {}".format(slot, port)
            else:
                print "Warning: generatePortList skipping star range as not supported on this switch type: {}".format(port)
        elif RegexPort.match(port): # Port is in valid format
            portDict[port] = 1
        else: # Port is in an invalid format; don't add to dict, print an error message, don't raise exception 
            print "Warning: generatePortList skipping unexpected port format: {}".format(port)

    # Sort and return the list as a comma separated string
    portList = sorted(portDict, key=portValue)

    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, portList))
        else: debug("generatePortList OUT = {}".format(portList))
    return portList

def generatePortRange(portList, debugKey=None): # v3 - Given a list of ports, generates a compacted port list/range string for use on CLI commands
    # Ported from acli.pl; this version of this function only compacts ranges within same slot
    debug("generatePortRange IN = {}".format(portList))
    rangeMode = {'VSP Series': 2, 'ERS Series': 1, 'Summit Series': 1}
    elementList = []
    elementBuild = None
    currentType = None
    currentSlot = None
    currentPort = None
    currentChan = None
    rangeLast = None

    # First off, sort the list
    portList = sorted(portList, key=portValue)
    for port in portList:
        slotPort = re.split("([/:])", port) # Split on '/' (ERS/VSP) or ':'(XOS)
        # slotPort[0] = slot / slotPort[1] = separator ('/' or ':') / slotPort[2] = port / slotPort[4] = channel
        if len(slotPort) == 5: # slot/port/chan
            if elementBuild:
                if currentType == 's/p' and slotPort[0] == currentSlot and slotPort[2] == currentPort and currentChan and slotPort[4] == str(int(currentChan)+1):
                    currentChan = slotPort[4]
                    if rangeMode[Family] == 1:
                        rangeLast = currentChan
                    else: # rangeMode = 2
                        rangeLast = currentSlot + slotPort[1] + currentPort + slotPort[1] + currentChan
                    continue
                else: # Range complete
                    if rangeLast:
                        elementBuild += '-' + rangeLast
                    elementList.append(elementBuild)
                    elementBuild = None
                    rangeLast = None
                    # Fall through below
            currentType = 's/p'
            currentSlot = slotPort[0]
            currentPort = slotPort[2]
            currentChan = slotPort[4]
            elementBuild = port

        if len(slotPort) == 3: # slot/port
            if elementBuild:
                if currentType == 's/p' and slotPort[0] == currentSlot and slotPort[2] == str(int(currentPort)+1) and not currentChan:
                    currentPort = slotPort[2]
                    if rangeMode[Family] == 1:
                        rangeLast = currentPort
                    else: # rangeMode = 2
                        rangeLast = currentSlot + slotPort[1] + currentPort
                    continue
                else: # Range complete
                    if rangeLast:
                        elementBuild += '-' + rangeLast
                    elementList.append(elementBuild)
                    elementBuild = None
                    rangeLast = None
                    # Fall through below
            currentType = 's/p'
            currentSlot = slotPort[0]
            currentPort = slotPort[2]
            currentChan = None
            elementBuild = port

        if len(slotPort) == 1: # simple port (no slot)
            if elementBuild:
                if currentType == 'p' and port == str(int(currentPort)+1):
                    currentPort = port
                    rangeLast = currentPort
                    continue
                else: # Range complete
                    if rangeLast:
                        elementBuild += '-' + rangeLast
                    elementList.append(elementBuild)
                    elementBuild = None
                    rangeLast = None
                    # Fall through below
            currentType = 'p'
            currentPort = port
            elementBuild = port

    if elementBuild: # Close off last element we were holding
        if rangeLast:
            elementBuild += '-' + rangeLast
        elementList.append(elementBuild)

    portStr = ','.join(elementList)
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, portStr))
        else: debug("generatePortRange OUT = {}".format(portStr))
    return portStr


#
# Linux shell functions (requires CLI functions)
# v3
import re
import os
import subprocess

def xmcLinuxExecute(cmd): # v1 - Execute a command on XMC for which no output expected
    debug("xmcLinuxExecute about to execute : {}".format(cmd))
    try:
        os.system(cmd)
        return True
    except Exception as e: # Expect OSError
        print "{}: {}".format(type(e).__name__, str(e))
        print "Error executing '{}' on XMC shell".format(cmd)
        return False

def xmcLinuxCommand(cmdRegexStr, debugKey=None): # v2 - Execute a command on XMC and recover the output
    mode, cmdList, regex = parseRegexInput(cmdRegexStr)
    cmd = cmdList[0] # We only support single shell command syntax for now
    cmdList = cmd.split(' ')
    try:
        emc_vars
    except: # If not running on XMC Jython...I develop on my Windows laptop...
        cmdList[0] += '.bat'
    debug("xmcLinuxCommand about to execute : {}".format(cmd))
    try:
        outputStr = subprocess.check_output(cmdList)
    except Exception as e: # Expect OSError
        print "{}: {}".format(type(e).__name__, str(e))
        print "Error executing '{}' on XMC shell".format(cmd)
        return
    data = re.findall(regex, outputStr, re.MULTILINE)
    # Format we return data in depends on what '&lt;type&gt;://' was pre-pended to the cmd &amp; regex
    value = formatOutputData(data, mode)
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, value))
        else: debug("xmcLinuxCommand OUT = {}".format(value))
    return value


#
# Other Custom Functions
#
def extractMltAndPortData(mltInclude=[], portInclude=[]): # Extract MLT data (include = ['fa','lacp','vlacp']) / and Port data (include = ['fa','lacp','vlacp'])
    # Only supported for family = 'VSP Series'
    mltDict = {}
    portDict = {}
    mltData = sendCLI_showRegex(CLI_Dict[Family]['get_mlt_data'])
    if 'fa' in mltInclude or 'fa' in portInclude:
        faData = sendCLI_showRegex(CLI_Dict[Family]['list_fa_interfaces'])
        for tpl in faData:
            enableFlag = True if tpl[1] == 'enabled' else False
            faMgmt = tpl[3]+':'+tpl[2] if tpl[3] != '0' and tpl[2] != '0' else None
            faAuth = True if tpl[4] == 'enabled' else False
            portDict[tpl[0]] = {'fa': enableFlag, 'faAuth': faAuth, 'faMgmt': faMgmt, 'key': None, 'lacp': False, 'mlt': None, 'vlacp': False}
            # Keys of portDict might include MLT-ids; these would be deleted below
    if 'lacp' in mltInclude or 'lacp' in portInclude:
        lacpPortData = sendCLI_showRegex(CLI_Dict[Family]['get_lacp_port_data'])
        for tpl in lacpPortData:
            enableFlag = True if tpl[2] == 'true' else False
            if tpl[0] not in portDict:
                if enableFlag:
                    portDict[tpl[0]] = {'fa': None, 'faAuth': None, 'faMgmt': None, 'key': tpl[1], 'lacp': enableFlag, 'mlt': None, 'vlacp': False}
                continue
            portDict[tpl[0]]['key'] = tpl[1]
            portDict[tpl[0]]['lacp'] = enableFlag
    if 'lacp' in mltInclude:
        lacpMltKey = sendCLI_showRegex(CLI_Dict[Family]['list_mlt_lacp_key'])
    for tpl in mltData:
        if tpl[0]:
            mltDict[tpl[0]] = {'type': tpl[1], 'ports': tpl[2]}
        elif tpl[3]:
            mltDict[tpl[3]]['lacp'] = True if tpl[4] == 'enable' else False
        elif tpl[5]:
            mltDict[tpl[5]]['flex'] = True if tpl[6] == 'enable' else False
    for mltid in mltDict:
        for port in generatePortList(mltDict[mltid]['ports']):
            if port not in portDict:
                portDict[port] = {'fa': None, 'faAuth': None, 'faMgmt': None, 'key': None, 'lacp': False, 'mlt': None, 'vlacp': False}
            portDict[port]['mlt'] = mltid
    for mltid in mltDict:
        if mltid in portDict:
            if 'fa' in mltInclude:
                mltDict[mltid]['fa'] = portDict[mltid]['fa']
                mltDict[mltid]['faAuth'] = portDict[mltid]['faAuth']
                mltDict[mltid]['faMgmt'] = portDict[mltid]['faMgmt']
            del portDict[mltid] # We no longer need it
        elif 'fa' in mltInclude:
            mltDict[mltid]['fa'] = None
            mltDict[mltid]['faAuth'] = None
            mltDict[mltid]['faMgmt'] = None
    if 'vlacp' in portInclude:
        vlacpData = sendCLI_showRegex(CLI_Dict[Family]['list_vlacp_ports'].format('')) # All ports
    elif 'vlacp' in mltInclude:
        vlacpData = sendCLI_showRegex(CLI_Dict[Family]['list_vlacp_ports'].format(generatePortRange(portDict.keys()))) # Only MLT ports
    if 'vlacp' in mltInclude:
        for mltid in mltDict:
            mltDict[mltid]['vlacp'] = False
        for port in vlacpData:
            if vlacpData[port] == 'true' and port in portDict and portDict[port]['mlt']:
                mltDict[portDict[port]['mlt']]['vlacp'] = True
    if 'vlacp' in portInclude:
        for port in vlacpData:
            if vlacpData[port] == 'true':
                if port not in portDict:
                    portDict[port] = {'fa': None, 'faAuth': None, 'faMgmt': None, 'key': None, 'lacp': False, 'mlt': None, 'vlacp': True}
                else:
                    portDict[port]['vlacp'] = True
    if 'lacp' in mltInclude:
        for mltid in mltDict:
            mltDict[mltid]['key'] = None
        for mltid in lacpMltKey:
            mltDict[mltid]['key'] = lacpMltKey[mltid]
            matchingKeyPortList = [x for x in portDict if portDict[x]['key'] == lacpMltKey[mltid]]
            # This overwrites the ports, but at least we get in there all ports configured with matching LACP key (not just ports active in MLT LAG)
            mltDict[mltid]['ports'] = generatePortRange(matchingKeyPortList)

    debug("extractMltAndPortData() mltDict = {}".format(mltDict))
    debug("extractMltAndPortData() portDict = {}".format(portDict))
    # mltDict: will include info of all MLTs
    # {"id" {'fa': None|True|False, 'faAuth': True|False, 'faMgmt': "vlan:isid", 'flex': True|False, 'key': None|"key", 'lacp': True|False, 'ports': "port-range", 'type': "smlt|norm", 'vlacp': True|False}}
    # portDict: will include info of all ports which are either FA enabled or LACP enabled or assigned to an MLT (statically or via LACP) [so not all ports]
    # {"port": {'fa': None|True|False, 'faAuth': True|False, 'faMgmt': "vlan:isid", 'key':None|"key", 'lacp': True|False, 'mlt': None|"id", 'vlacp': True|False}}
    return mltDict, portDict, faData


#
# INIT: Init code
#
try:
    if emc_vars['userInput_sanity'] == 'Enable':
        Sanity = True
    elif emc_vars['userInput_sanity'] == 'Disable':
        Sanity = False
except:
    pass
try:
    if emc_vars['userInput_debug'] == 'Enable':
        Debug = True
    elif emc_vars['userInput_debug'] == 'Disable':
        Debug = False
except:
    pass


#
# Imports:
#
from distutils.version import LooseVersion


#
# Variables:
#

NtpList  = [] #['10.8.255.160', '10.8.255.159'] # Set statically if you cannot use NBI to obtain from XMC
TimeZone = [] #['GMT', '+00', '00']             # Set statically if you cannot use NBI to obtain from XMC

NBI_Query = { # GraphQl query / outValue = nbiQuery(NBI_Query['getDeviceUserData'], IP=deviceIp)
# QUERIES (General):
    'nbiAccess': {
        'json': '''
                {
                  administration {
                    serverInfo {
                      version
                    }
                  }
                }
                ''',  
        'key': 'version'
    },
    'nacConfig': {
        'json': '''
                {
                  accessControl {
                    switch(ipAddress: "&lt;IP&gt;") {
                      primaryGateway
                      secondaryGateway
                      overrideSharedSecret
                      sharedSecret
                    }
                  }
                }
                ''',
        'key': 'switch'
    },
}


CLI_Dict = {
    'VSP Series': {
        'disable_more_paging'        : 'terminal more disable',
        'enable_context'             : 'enable',
        'config_context'             : 'config term',
        'port_config_context'        : 'interface gigabitEthernet {}', # Port list
        'mlt_config_context'         : 'interface mlt {}', # MLT id
        'exit_config_context'        : 'exit',
        'end_save_config'            : 'end; save config',

        'list_radius_ept_servers'    : 'list://show radius-server ||^(\d+\.\d+\.\d+\.\d+) +endpoint-tracking',
        'list_radius_clients'        : 'list://show radius dynamic-server ||^(\d+\.\d+\.\d+\.\d+) +',
        'get_mlt_data'               : 'list://show mlt||^(?:(\d+) +\d+.+?(?:access|trunk) +(norm|smlt) +(?:norm|smlt) *(\S+)?|(\d+) +\d+ +(?:[\d\/]+|null) +(enable|disable)|(\d+) +\d+ +\S+ +\S+ +\S+ +\S+ +\S+ +(enable|disable))',
        'list_fa_interfaces'         : 'list://show fa interface||^(?:Mlt|Port)(\d+(?:/\d+(?:/\d+)?)?) +(enabled|disabled) +(\d+) +(\d+) +(enabled|disabled)',
        'get_lacp_port_data'         : 'list://show lacp actor-oper interface||^(\d+/\d+(?:/\d+)?) +(\d+) +\d+ +\d+ +(true|false)',
        'list_mlt_lacp_key'          : 'dict://show lacp interface mlt||^(\d+) +\d+ +\d+ +\S+ +\d+ +(\d+)',
        'list_nni_interfaces'        : 'list://show isis interface||^(?:Mlt|Port)(\d+(?:/\d+(?:/\d+)?)?) +',
        'list_brouter_ports'         : 'list://show brouter||^\s*(\d+/\d+(?:/\d+)?) +\d+',
        'list_slpp_ports'            : 'list://show slpp interface gigabitEthernet||^(\d+/\d+(?:/\d+)?) +enabled',
        'get_auto_sense_status'      : 'dict://show interfaces gigabitEthernet auto-sense {}||^(\d+/\d+(?:/\d+)?) +(\S+)', # Port
        'get_flex_uni'               : 'dict://show interfaces gigabitEthernet config {}||^(\d+/\d+(?:/\d+)?) +\S+ +\S+ +\S+ +\S+ +\S+ +(Enable|Disable)', # Port
        'list_ntp_servers'           : 'list://show ntp server ||^(\d+\.\d+\.\d+\.\d+)',
        'delete_ntp_server'          : 'no ntp server {}', # IP
        'create_ntp_server'          : 'ntp server {} enable', # IP
        'enable_ntp'                 : 'ntp',
        'set_timezone'               : 'clock time-zone {} {}', # Zone
        'delete_radius_server'       : 'no radius server host {} used-by endpoint-tracking', # IP
        'delete_radius_client'       : 'no radius dynamic-server client {}', # IP
        'update_radius_server'       : # {0} = Radius Server IP, {1} = Radius secret
                                       '''
                                       radius server host {0} used-by endpoint-tracking key {1}
                                       radius sourceip-flag
                                       ''',
        'update_radius_server_lns'   : 'radius server host {0} used-by endpoint-tracking key {1}', # {0} = Radius Server IP, {1} = Radius secret
        'create_radius_server'       : # {0} = Radius Server IP, {1} = Radius secret, {2} = Source IP
                                       '''
                                       radius server host {0} key {1} used-by endpoint-tracking source-ip {2}
                                       radius sourceip-flag
                                       ''',
        'create_radius_server_lns'   : 'radius server host {0} key {1} used-by endpoint-tracking', # {0} = Radius Server IP, {1} = Radius secret
        'create_radius_client'       : 'radius dynamic-server client {0} secret {1} enable', # {0} = Radius Server IP, {1} = Radius secret
        'enable_radius'              : 'radius enable',
        'enable_ept_isid_offset'     : 'endpoint-tracking auto-isid-offset {}; endpoint-tracking auto-isid-offset enable', # I-SID
        'disable_ept_isid_offset'    : 'no endpoint-tracking auto-isid-offset enable; default endpoint-tracking auto-isid-offset',
        'enable_ept_visibility_mode' : 'endpoint-tracking visibility-mode',
        'disable_ept_visibility_mode': 'no endpoint-tracking visibility-mode',
        'enable_ept'                 : 'endpoint-tracking enable',
        'disable_ept'                : 'no endpoint-tracking enable',
        'delete_ept'                 : 'no endpoint-tracking',
        'enable_flex_uni'            : 'flex-uni enable',
        'disable_autosense'          : 'interface gigabitEthernet {0}; no auto-sense enable; exit', # Port
        'create_flex_uni'            : 'vlan members remove 1 {0}; interface gigabitEthernet {0}; flex-uni enable; exit', # Port
        'ports_enable_ept'           : 'interface gigabitEthernet {0}; endpoint-tracking enable; exit', # Port
        'ports_disable_ept'          : 'interface gigabitEthernet {0}; no endpoint-tracking enable; exit', # Port
        'ports_delete_ept'           : 'interface gigabitEthernet {0}; no endpoint-tracking; exit', # Port
        'port_enable_spoof_detect'   : 'spoof-detect',
        'port_disable_spoof_detect'  : 'no spoof-detect',
        'disable_slpp_packet_rx'     : 'no slpp packet-rx; default slpp packet-rx-threshold',
        'port_enable_slpp_guard'     : 'slpp-guard enable',
        'port_disable_slpp_guard'    : 'no slpp-guard enable',
        'port_enable'                : 'no shutdown',
    },
}

Shell_Dict = { # Dictionary of all Linux shell commands used by this script
    'list_ntp_servers'           : 'list://ntpq -pn ||^[*+](\d+\.\d+\.\d+\.\d+)',
    'list_ntp_servers_84'        : 'list://chronyc -n sources ||^\^[*+-]\s*(\d+\.\d+\.\d+\.\d+)',
    'get_time_zone'              : 'tuple:// timedatectl ||Time zone: (\S+?)(?:/(\S+?))? \((\w+?), ([-+]\d\d)(\d\d)\)',
}


#
# Main:
#
def main():
    print "VSP-EPT-Enforce version {} on XMC version {}".format(__version__, emc_vars["serverVersion"])
    nbiAccess = nbiQuery(NBI_Query['nbiAccess'], returnKeyError=True)
    if nbiAccess == None:
        raise RuntimeError('This XMC Script requires access to the GraphQl North Bound Interface (NBI). Make sure that XMC is running with an Advanced license and that your user profile is authorized for Northbound API.')

    #
    # Obtain Info on switch and from XMC
    #
    setFamily() # Sets global Family variable
    vossSegMgmt = LooseVersion(emc_vars["deviceSoftwareVer"]) &gt;= LooseVersion("8.2")
    debug("vossSegMgmt = {}".format(vossSegMgmt))
    try:
        enteredPortList = generatePortList(emc_vars['port'])
    except:
        enteredPortList = []
    debug("enteredPortList = {}".format(enteredPortList))

    eptPortMode = emc_vars['userInput_eptPortMode'].split(':', 1)[0]

    try:
        enteredMltIds = emc_vars["userInput_mltIdList"].strip()
    except:
        enteredMltIds = None

    autoIsid = emc_vars['userInput_autoIsidOffset']
    if autoIsid:
        isidMatch = re.search(r'(\d+$)', emc_vars['userInput_autoIsidOffset'])
        if isidMatch:
            autoIsid = 'Enable'
            autoIsidOffset = isidMatch.group(1)
        else:
            autoIsid = 'Disable'
            autoIsidOffset = ''
    else:
        autoIsid = ''
        autoIsidOffset = ''

    visibilityMode = emc_vars['userInput_visibilityMode']
    spoofDetect = emc_vars['userInput_spoofDetect']
    slppGuard = emc_vars['userInput_slppGuard']

    print "Information provided by User:"
    print " - Switch access ports where to configure EPT = {}".format(generatePortRange(enteredPortList))
    print " - EPT Port Mode = {}".format(eptPortMode)
    print " - Optional MLT id list = {}".format(enteredMltIds)
    print " - EPT Auto-ISID = {}".format(autoIsid)
    print " - EPT Auto-ISID-Offset = {}".format(autoIsidOffset)
    print " - EPT Visibility Mode = {}".format(visibilityMode)
    print " - Spoof-Detect = {}".format(spoofDetect)
    print " - SLPP-Guard = {}".format(slppGuard)

    if enteredMltIds: # Prime the list with any MLT-ids the user entered
        enteredMltList = generatePortList(enteredMltIds)
    else:
        enteredMltList = []
    debug("enteredMltList = {}".format(enteredMltList))

    if eptPortMode == 'Enable': # All this info won't be needed if we are just going to delete/disable EPT on selcted ports
        vspIP  = emc_vars['deviceIP']
        print "Extracted information from XMC:"
        print " - Switch IP = {}".format(vspIP)

        # This GraphQl query will fail if the switch IP is not already configured as a NAC switch in XMC Control
        nacConfig = nbiQuery(NBI_Query['nacConfig'], IP=vspIP)
        #  "switch": { # Sample of what we get back
        #    "primaryGateway": "10.8.255.17",
        #    "secondaryGateway": null,
        #    "sharedSecret": "radius",
        #    "overrideSharedSecret": true  # Currently we only work if this is set, and hence sharedSecret returned
        #  }
        #  Or, if switch not configured under XMC Access  Control:
        #  "switch": null
        if nacConfig == None: # Switch is not configured under XMC Access Control; give a meaningful error message
            raise RuntimeError('Switch {} does not exist under XMC Access-Control'.format(vspIP))
        print " - {} configured under XMC Access Control Switches, with:".format(vspIP)
        print "    - Primary XMC Radius server = {}".format(nacConfig['primaryGateway'])
        print "    - Secondary XMC Radius server = {}".format(nacConfig['secondaryGateway'])
        print "    - XMC switch overrideSharedSecret (must be true) = {}".format(nacConfig['overrideSharedSecret'])
        print "    - XMC configured Radius secret = {}".format(nacConfig['sharedSecret'])
        if not nacConfig['overrideSharedSecret']: # Switch is configured under XMC Access Control, but the sharedsecret is set under engine settings, and we can't get to it with NBI currently
            raise RuntimeError('Switch {} does not have an override RADIUS shared secret set (this script cannot currently work with shared secret set under engine settings)'.format(vspIP))

        if NtpList and TimeZone: # We have static overrides
            xmcNtpList = NtpList
            xmcTimeZone = TimeZone
            print " - Static NTP Server 1 = {}".format(xmcNtpList[0])
            if len(xmcNtpList) &gt; 1:
                print " - Static NTP Server 2 = {}".format(xmcNtpList[1])
            print " - Static Time Zone = {} {}:{}".format(xmcTimeZone[0], xmcTimeZone[1], xmcTimeZone[2])
        else: # Obtain from XMC via Linux shell
            if LooseVersion(emc_vars["serverVersion"]) &gt;= LooseVersion("8.4"): # Required for XMC 8.4.x and above
                xmcNtpList = xmcLinuxCommand(Shell_Dict['list_ntp_servers_84'], 'xmcNtpList')
            else: # This works up to XMC versions 8.3.x
                xmcNtpList = xmcLinuxCommand(Shell_Dict['list_ntp_servers'], 'xmcNtpList')
            if xmcNtpList:
                print " - XMC NTP Server 1 = {}".format(xmcNtpList[0])
                if len(xmcNtpList) &gt; 1:
                    print " - XMC NTP Server 2 = {}".format(xmcNtpList[1])
    
                xmcTimeZone = xmcLinuxCommand(Shell_Dict['get_time_zone'], 'xmcTimeZone')
                print " - XMC Time Zone = {} {} / {} {}:{}".format(xmcTimeZone[0], xmcTimeZone[1], xmcTimeZone[2], xmcTimeZone[3], xmcTimeZone[4])
    
            else:
                print " - Unable to extract XMC NTP Server configuration (=&gt; NTP/SNTP and CoA replay-protect will not be configured on switch)"
        print

    # First off, disable more paging
    sendCLI_showCommand(CLI_Dict[Family]['disable_more_paging'])

    # Enter privExec mode
    sendCLI_showCommand(CLI_Dict[Family]['enable_context'])

    if eptPortMode == 'Enable': # Not needed if we are just going to delete/disable EPT on selcted ports
        # Extract RADIUS server config
        radiusEptServerList = sendCLI_showRegex(CLI_Dict[Family]['list_radius_ept_servers'], 'radiusEptServerList')
        radiusEptServerDeleteList = [x for x in radiusEptServerList if x != nacConfig['primaryGateway'] and x != nacConfig['secondaryGateway']]
        radiusEptServerUpdateList = [x for x in radiusEptServerList if x == nacConfig['primaryGateway'] or  x == nacConfig['secondaryGateway']]
        radiusEptServerCreateList = [x for x in (nacConfig['primaryGateway'], nacConfig['secondaryGateway']) if x not in radiusEptServerUpdateList]
        debug("radiusEptServerDeleteList = {}".format(radiusEptServerDeleteList))
        debug("radiusEptServerUpdateList = {}".format(radiusEptServerUpdateList))
        debug("radiusEptServerCreateList = {}".format(radiusEptServerCreateList))

        radiusClientsList = sendCLI_showRegex(CLI_Dict[Family]['list_radius_clients'], 'radiusClientsList')
        radiusClientsDeleteList = [x for x in radiusClientsList if x == nacConfig['primaryGateway'] or x == nacConfig['secondaryGateway']]
        debug("radiusClientsDeleteList = {}".format(radiusClientsDeleteList))

    eptPortList = []
    eptMltList = []
    eptPortRange = None
    if enteredPortList or enteredMltList: # Only if some ports were selected
        # Extract MLT &amp; port data; we also get FA interface data from here directly
        mltDict, portDict, faData = extractMltAndPortData(['fa', 'lacp'], ['fa', 'lacp'])
        faInterfaceList = [x[0] for x in faData]
        debug("faInterfaceList = {}".format(faInterfaceList))

        # Dump NNI interfaces - obtain list of ports &amp; mltids
        nniInterfaceList = sendCLI_showRegex(CLI_Dict[Family]['list_nni_interfaces'], 'nniInterfaceList')

        # Get list of any Brouter ports (could be used for mgmt or Fabric Extend..)
        brouterPortList = sendCLI_showRegex(CLI_Dict[Family]['list_brouter_ports'], 'brouterPortList')

        if slppGuard:
            # Get list of any SLPP enabled ports (if my SMLT-Pair-Enforce script was used to create SMLT MLTs, these will have regular SLPP on them..)
            slppPortList = sendCLI_showRegex(CLI_Dict[Family]['list_slpp_ports'], 'slppPortList')

        # Condense NNI interfaces (any FA MLTs are converted to individual ports)
        nniPortDict = {} # Use a Dict so that keys are unique
        nniMltDict = {} # Use a Dict so that keys are unique
        for interface in nniInterfaceList:
            if re.match(r'^\d+$' ,interface): # MLT id
                nniMltDict[interface] = 1
                for port in generatePortList(mltDict[interface]['ports']):
                    nniPortDict[port] = 1
            else: # Port
                nniPortDict[interface] = 1
        nniPortList = nniPortDict.keys()
        nniMltList = nniMltDict.keys()
        debug("nniPortList = {}".format(nniPortList))
        debug("nniMltList = {}".format(nniMltList))

        # Condense FA interfaces (any NNI MLTs are converted to individual ports)
        faPortDict = {} # Use a Dict so that keys are unique
        faMltDict = {} # Use a Dict so that keys are unique
        for interface in faInterfaceList:
            if re.match(r'^\d+$', interface): # MLT id
            	faMltDict[interface] = 1
                for port in generatePortList(mltDict[interface]['ports']):
                    faPortDict[port] = 1
            else: # Port
                faPortDict[interface] = 1
        faPortList = faPortDict.keys()
        faMltList = faMltDict.keys()
        debug("faPortList = {}".format(faPortList))
        debug("faMltDict = {}".format(faMltList))

        # Identify NNI ports in selection
        nniPortsInSelection = [x for x in enteredPortList if x in nniPortList]
        nniMltsInSelection = [x for x in enteredMltList if x in nniMltList]
        debug("nniPortsInSelection = {}".format(nniPortsInSelection))
        debug("nniMltsInSelection = {}".format(nniMltsInSelection))
        # Identify FA ports in selection
        faPortsInSelection = [x for x in enteredPortList if x in faPortList]
        faMltsInSelection = [x for x in enteredMltList if x in faMltList]
        debug("faPortsInSelection = {}".format(faPortsInSelection))
        debug("faMltsInSelection = {}".format(faMltsInSelection))
        # Identify Brouter ports in selection
        brouterPortsInSelection = [x for x in enteredPortList if x in brouterPortList]
        debug("brouterPortsInSelection = {}".format(brouterPortsInSelection))
        # Subtract NNI,FA,Brouter ports from selection
        prunedPortList = [x for x in enteredPortList if x not in nniPortList and x not in faPortList and x not in brouterPortList]
        prunedMltList = [x for x in enteredMltList if x not in nniMltList and x not in faMltList]
        debug("prunedPortList = {}".format(prunedPortList))
        debug("prunedMltList = {}".format(prunedMltList))
        prunedPortRange = generatePortRange(prunedPortList)
        if slppGuard:
            regSlppRemoveList = [x for x in prunedPortList if x in slppPortList]
            debug("regSlppRemoveList = {}".format(regSlppRemoveList))
            if regSlppRemoveList:
                regSlppRemoveRange = generatePortRange(regSlppRemoveList)

        # Determine ports and MLT ids to configure for EPT
        for port in prunedPortList:
            if port in portDict and portDict[port]['mlt'] and portDict[port]['mlt'] not in prunedMltList:
                prunedMltList.append(portDict[port]['mlt'])
            else:
                eptPortList.append(port)
        debug("eptPortList = {}".format(eptPortList))
        eptMltList = [str(x) for x in sorted([int(x) for x in prunedMltList])] # Sort the MLT ids
        debug("eptMltList = {}".format(eptMltList))
        eptPortRange = generatePortRange(eptPortList)
        debug("eptPortRange = {}".format(eptPortRange))

        if eptPortMode == 'Enable': # Not needed if we are just going to delete/disable EPT on selcted ports
            # Check which of the future EPT ports will also require Auto-sense disabling and Flex-Uni enabling
            autoSenseEnabledRange = None
            flexUniDisabledRange = None
            if eptPortList:
                # Get auto-sense status for selected ports
                autoSensePortDict = sendCLI_showRegex(CLI_Dict[Family]['get_auto_sense_status'].format(eptPortRange), 'autoSensePortDict', True)
                autoSenseEnabledList = [x for x in autoSensePortDict if autoSensePortDict[x] == 'Enable']
                debug("autoSenseEnabledList = {}".format(autoSenseEnabledList))
                autoSenseEnabledRange = generatePortRange(autoSenseEnabledList)

                # Get flex-uni status for selected ports
                flexUniList = sendCLI_showRegex(CLI_Dict[Family]['get_flex_uni'].format(eptPortRange), 'flexUniList')
                flexUniDisabledList = [x for x in flexUniList if x in autoSenseEnabledList or flexUniList[x] == 'Disable']
                debug("flexUniDisabledList = {}".format(flexUniDisabledList))
                flexUniDisabledRange = generatePortRange(flexUniDisabledList)

    if eptPortMode == 'Enable' and xmcNtpList: # Only if XMC is configured with NTP server(s)
        # Get NTP servers already configured on switch, if any
        switchNtpList = sendCLI_showRegex(CLI_Dict[Family]['list_ntp_servers'], 'switchNtpList')

    if enteredPortList or enteredMltList or (eptPortMode == 'Enable' and xmcNtpList):
        print "Extracted information from VSP switch via CLI:"
        if enteredPortList or enteredMltList: # Only if some ports were selected
            print " - VSP NNI ports = {}".format(generatePortRange(nniPortList))
            print " - VSP FA ports = {}".format(generatePortRange(faPortList))
            print " - EPT MLTs to configure = {}".format(generatePortRange(eptMltList))
            print " - EPT ports to configure = {}".format(eptPortRange)
            if eptPortMode == 'Enable': # Not needed if we are just going to delete/disable EPT on selcted ports
                print " - EPT ports to Auto-Sense disable = {}".format(autoSenseEnabledRange)
                print " - EPT ports to Flex-Uni enable = {}".format(flexUniDisabledRange)
                print " - EPT ports to bring up (no shut) = {}".format(prunedPortRange)
                if spoofDetect:
                    print " - EPT ports to Spoof-Detect enable/disable = {}".format(prunedPortRange)
                if slppGuard:
                    print " - EPT ports to SLPP-Guard enable/disable = {}".format(prunedPortRange)
                    if regSlppRemoveList:
                        print " - EPT ports where to remove regular SLPP before setting SLPP-Guard = {}".format(regSlppRemoveRange)
        if eptPortMode == 'Enable' and xmcNtpList: # Only if XMC is configured with NTP server(s)
            print " - Existing NTP Servers = {}".format(', '.join(switchNtpList))
        print " - EPT RADIUS servers configured = {}".format(', '.join(radiusEptServerList))
        print " - EPT RADIUS servers to delete = {}".format(', '.join(radiusEptServerDeleteList))
        print " - EPT RADIUS servers to update = {}".format(', '.join(radiusEptServerUpdateList))
        print " - EPT RADIUS servers to create = {}".format(', '.join(radiusEptServerCreateList))
        print " - EPT Dynamic RADIUS clients configured = {}".format(', '.join(radiusClientsList))
        print " - EPT Dynamic RADIUS clients to re-create = {}".format(', '.join(radiusClientsDeleteList))
        print

    #
    # Now configure the switch
    #
    # Enter config mode
    sendCLI_configCommand(CLI_Dict[Family]['config_context'])

    if eptPortMode == 'Enable': # Not needed if we are just going to delete/disable EPT on selcted ports

        if xmcNtpList: # Only if XMC is configured with NTP server(s)
            deleteNtpServers = False
            createNtpServers = False
            # If switch configured NTP servers are not the XMC ones, delete them all
            if xmcNtpList[0] not in switchNtpList or (len(xmcNtpList) == 2 and xmcNtpList[1] not in switchNtpList):
                deleteNtpServers = True
                createNtpServers = True

            if deleteNtpServers:
                for ntpIp in switchNtpList:
                    sendCLI_configCommand(CLI_Dict[Family]['delete_ntp_server'].format(ntpIp))
            if createNtpServers:
                for ntpIp in xmcNtpList:
                    sendCLI_configCommand(CLI_Dict[Family]['create_ntp_server'].format(ntpIp))
            sendCLI_configChain(CLI_Dict[Family]['enable_ntp'])

            # Set the time-zone
            sendCLI_configCommand(CLI_Dict[Family]['set_timezone'].format(xmcTimeZone[0], xmcTimeZone[1]))

        debug("radiusEptServerDeleteList = {}".format(radiusEptServerDeleteList))
        debug("radiusEptServerUpdateList = {}".format(radiusEptServerUpdateList))
        debug("radiusEptServerCreateList = {}".format(radiusEptServerCreateList))

        # Delete existing EPT RADIUS servers
        for server in radiusEptServerDeleteList:
            sendCLI_configChain(CLI_Dict[Family]['delete_radius_server'].format(server))
        for server in radiusClientsDeleteList:
            sendCLI_configChain(CLI_Dict[Family]['delete_radius_client'].format(server))

        # Update RADIUS servers
        for server in radiusEptServerUpdateList:
            if vossSegMgmt:
                sendCLI_configChain(CLI_Dict[Family]['update_radius_server_lns'].format(server, nacConfig['sharedSecret']))
            else:
                sendCLI_configChain(CLI_Dict[Family]['update_radius_server'].format(server, nacConfig['sharedSecret'], vspIP))

        # Configure RADIUS servers
        for server in radiusEptServerCreateList:
            if vossSegMgmt:
                sendCLI_configChain(CLI_Dict[Family]['create_radius_server_lns'].format(server, nacConfig['sharedSecret']))
            else:
                sendCLI_configChain(CLI_Dict[Family]['create_radius_server'].format(server, nacConfig['sharedSecret'], vspIP))

        # Enable RADIUS
        sendCLI_configChain(CLI_Dict[Family]['enable_radius'])

        if autoIsid or visibilityMode:

            # Disable EPT globally (in case it was enabled, otherwise global values cannot be set)
            sendCLI_configChain(CLI_Dict[Family]['disable_ept'])

            # Configure EPT global settings
            if autoIsid == 'Enable':
                sendCLI_configChain(CLI_Dict[Family]['enable_ept_isid_offset'].format(autoIsidOffset))
            elif autoIsid == 'Disable':
                sendCLI_configChain(CLI_Dict[Family]['disable_ept_isid_offset'])

            if visibilityMode == 'Enable':
                sendCLI_configChain(CLI_Dict[Family]['enable_ept_visibility_mode'])
            elif visibilityMode == 'Disable':
                sendCLI_configChain(CLI_Dict[Family]['disable_ept_visibility_mode'])

        # Enable EPT Globally
        sendCLI_configChain(CLI_Dict[Family]['enable_ept'])

    if eptPortRange or eptMltList: # Only if some ports/MLTs to configure

        # Configure EPT on MLTs
        for mltid in eptMltList:

            # Enter MLT config context
            sendCLI_configCommand(CLI_Dict[Family]['mlt_config_context'].format(mltid))

            if eptPortMode == 'Enable':
                # Enable Flex-Uni if necessary
                if not mltDict[mltid]['flex']: 
                    sendCLI_configChain(CLI_Dict[Family]['enable_flex_uni'])
                # Enable EPT
                sendCLI_configChain(CLI_Dict[Family]['enable_ept'])

            elif eptPortMode == 'Disable':
                # Disable EPT
                sendCLI_configChain(CLI_Dict[Family]['disable_ept'])

            elif eptPortMode == 'None':
                # Delete EPT
                sendCLI_configChain(CLI_Dict[Family]['delete_ept'])

            # Come out of MLT config context
            sendCLI_configCommand(CLI_Dict[Family]['exit_config_context'])

        # Configure EPT on Ports
        if eptPortMode == 'Enable':
            sendCLI_configChain(CLI_Dict[Family]['disable_autosense'].format(eptPortRange), True, 'this VSP does not yet implement auto-sense')
            if flexUniDisabledRange:
                # Enable Flex-Uni (also removes default VLAN 1) on those ports where Flex-Uni is not already enabled
                sendCLI_configChain(CLI_Dict[Family]['create_flex_uni'].format(flexUniDisabledRange))
            if eptPortList:
                sendCLI_configChain(CLI_Dict[Family]['ports_enable_ept'].format(eptPortRange))

        elif eptPortMode == 'Disable' and eptPortList:
            # Disable EPT
            sendCLI_configChain(CLI_Dict[Family]['ports_disable_ept'].format(eptPortRange))

        elif eptPortMode == 'None' and eptPortList:
            # Delete EPT
            sendCLI_configChain(CLI_Dict[Family]['ports_delete_ept'].format(eptPortRange))

        # Enable individual ports and set Spoof-Detect / SLPP-Guard if requested
        if eptPortMode == 'Enable' and prunedPortList:
            # Enter Port config context (individual ept ports + MLT ept ports)
            sendCLI_configCommand(CLI_Dict[Family]['port_config_context'].format(prunedPortRange))

            # Apply Spoof-Detect config if this was specified 
            if spoofDetect == 'Enable':
                sendCLI_configChain(CLI_Dict[Family]['port_enable_spoof_detect'].format(prunedPortRange))
            elif spoofDetect == 'Disable':
                sendCLI_configChain(CLI_Dict[Family]['port_disable_spoof_detect'].format(prunedPortRange))

            # Apply SLPP-Guard config if this was specified 
            if slppGuard and regSlppRemoveList:
                sendCLI_configChain(CLI_Dict[Family]['disable_slpp_packet_rx'].format(regSlppRemoveRange))
            if slppGuard == 'Enable':
                sendCLI_configChain(CLI_Dict[Family]['port_enable_slpp_guard'].format(prunedPortRange))
            elif slppGuard == 'Disable':
                sendCLI_configChain(CLI_Dict[Family]['port_disable_slpp_guard'].format(prunedPortRange))

            # Bring up ports
            sendCLI_configChain(CLI_Dict[Family]['port_enable'].format(prunedPortRange))

            # Come out of port config context
            sendCLI_configCommand(CLI_Dict[Family]['exit_config_context'])

    # End config and save
    sendCLI_configChain(CLI_Dict[Family]['end_save_config'])

    # Print summary of config performed
    printConfigSummary()

    if enteredPortList: # Only if some ports were selected
        if nniPortsInSelection:
            print "Information: User selected ports {} were not EPT configured as these ports are NNI ports".format(generatePortRange(nniPortsInSelection))
        if faPortsInSelection:
            print "Information: User selected ports {} were not EPT configured as these ports are FA ports".format(generatePortRange(faPortsInSelection))
        if brouterPortsInSelection:
            print "Information: User selected ports {} were not EPT configured as these ports are Brouter ports".format(generatePortRange(brouterPortsInSelection))
    if eptPortMode == 'Enable' and not xmcNtpList: # In case we had to miss out the NTP config, produce warning at the very end
        print "Warning: It was not possible to obtain NTP server IPs &amp; Time-zone from XMC. Hence NTP was not configured on the VSP switch"

main()
</content>
    <creationDate>1584546599552</creationDate>
    <creator>lstevens</creator>
    <credentialsCacheOveride>false</credentialsCacheOveride>
    <defaultCategory></defaultCategory>
    <devicesRequired>true</devicesRequired>
    <encoded>true</encoded>
    <contexts>,Device,Groups,</contexts>
    <lastUpdateDate>1720529026916</lastUpdateDate>
    <lastUpdatedBy>lstevens</lastUpdatedBy>
    <miscXMLData></miscXMLData>
    <nosIds>,nos-id-fabric-engine,nos-id-voss,</nosIds>
    <postprocessScript></postprocessScript>
    <rollbackScript></rollbackScript>
    <saveConfigOnExit>false</saveConfigOnExit>
    <scriptOwner></scriptOwner>
    <scriptTimeout>60</scriptTimeout>
    <scriptType>Python</scriptType>
    <supprotedGroups></supprotedGroups>
    <roles>,XIQ-SE Administrator,</roles>
    <vendor></vendor>
    <version>0</version>
</script>

